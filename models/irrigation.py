# -*- coding: utf-8 -*-
"""Irrigation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rSVPoimruaiPL62siL3AbBrgrrfvBEHB
"""

import joblib
import pandas as pd
import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder,StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score,mean_squared_error,confusion_matrix,classification_report


project_root = Path(__file__).parent.parent
irrigation_freq_path = project_root / "datasets" / "irrigation_freq.csv"
place_path = project_root / "datasets" / "place.csv"

df = pd.read_csv(irrigation_freq_path)   # Crop-Fertilizer Dataset
df_place = pd.read_csv(place_path)   # State Nutrient Dataset


# Define thresholds for nutrient categories (example thresholds, adjust as needed)
n_low_threshold = 50
n_medium_threshold = 100
p_low_threshold = 30
p_medium_threshold = 60
k_low_threshold = 30
k_medium_threshold = 60

# Categorize N, P, and K into 'Low', 'Medium', and 'High'
df['N_category'] = df['N'].apply(lambda x: 'Low' if x < n_low_threshold else ('Medium' if x < n_medium_threshold else 'High'))
df['P_category'] = df['P'].apply(lambda x: 'Low' if x < p_low_threshold else ('Medium' if x < p_medium_threshold else 'High'))
df['K_category'] = df['K'].apply(lambda x: 'Low' if x < k_low_threshold else ('Medium' if x < k_medium_threshold else 'High'))

le_crop = LabelEncoder()
df['label_encoded'] = le_crop.fit_transform(df['label'])

# --- One-hot encode nutrient categories ---
df_encoded = pd.get_dummies(
    df,
    columns=['N_category', 'P_category', 'K_category'],
    drop_first=False
)

# --- Features (crop included) and target ---
X = df_encoded[
    ['temperature','humidity','soil_moisture','label_encoded',
     'N_category_Low','N_category_Medium','N_category_High',
     'P_category_Low','P_category_Medium','P_category_High',
     'K_category_Low','K_category_Medium','K_category_High']
]
Y = df_encoded['irrigation_frequency'] - 1   # 0-indexed target

# --- Train/Test split ---
X_train, X_test, Y_train, Y_test = train_test_split(
    X, Y, test_size=0.05, random_state=42
)

# --- Scale only numeric columns ---
sc = StandardScaler()
num_cols = ['temperature','humidity','soil_moisture']
X_train[num_cols] = sc.fit_transform(X_train[num_cols])
X_test[num_cols]  = sc.transform(X_test[num_cols])

# --- Train model ---
rf = RandomForestClassifier(random_state=42)
rf.fit(X_train, Y_train)

df

# Make predictions on the test set
Y_pred_rf = rf.predict(X_test)
print(Y_pred_rf + 1)

# Evaluate the Random Forest model
print('Random Forest Accuracy:', accuracy_score(Y_test, Y_pred_rf))
print('Random Forest Classification Report:\n', classification_report(Y_test, Y_pred_rf))

def get_dominant_nutrient_level(row, nutrient_type):
     nutrient_cols = [col for col in row.index if nutrient_type in col]
     return row[nutrient_cols].idxmax()

df_place['Dominant_N'] = df_place.apply(lambda row: get_dominant_nutrient_level(row, 'Nitrogen'), axis=1)
df_place['Dominant_P'] = df_place.apply(lambda row: get_dominant_nutrient_level(row, 'Phosphorous'), axis=1)
df_place['Dominant_K'] = df_place.apply(lambda row: get_dominant_nutrient_level(row, 'Potassium'), axis=1)


state_nutrient_map = df_place.set_index('State/UT')[['Dominant_N', 'Dominant_P', 'Dominant_K']].T.to_dict('dict')

# Display the dictionary (first few items) to verify
print("State Nutrient Mapping:")
for i, (state, nutrients) in enumerate(state_nutrient_map.items()):
    print(f"{state}: {nutrients}")
    if i > 5: # Display only first 5 for brevity
        break

def predict_irrigation_frequency(crop, temperature, humidity, soil_moisture,state):
    # single-row dict of all features
    dominant_nutrients = state_nutrient_map[state]
    dominant_n_str = dominant_nutrients['Dominant_N']
    dominant_p_str = dominant_nutrients['Dominant_P']
    dominant_k_str = dominant_nutrients['Dominant_K']

    # Map dominant nutrient level strings to the categories used in training ('Low', 'Medium', 'High')
    def simplify_nutrient_level(level_string):
        if 'Low' in level_string:
            return 'Low'
        elif 'M' in level_string:
            return 'Medium'
        elif 'High' in level_string or 'H' in level_string or 'VH' in level_string:
            return 'High'
        else:
            return 'Unknown'

    n_category = simplify_nutrient_level(dominant_n_str)
    p_category = simplify_nutrient_level(dominant_p_str)
    k_category = simplify_nutrient_level(dominant_k_str)

    # Encode the categorical nutrient level
    #n_encoded = le_crop.transform([n_category])[0]
    #p_encoded = le_crop.transform([p_category])[0]
    #k_encoded = le_crop.transform([k_category])[0]



    input_dict = {
        'temperature'      : temperature,
        'humidity'         : humidity,
        'soil_moisture'    : soil_moisture,
        'label_encoded'    : le_crop.transform([crop])[0],
        'N_category_Low'   : 0, 'N_category_Medium': 0, 'N_category_High': 0,
        'P_category_Low'   : 0, 'P_category_Medium': 0, 'P_category_High': 0,
        'K_category_Low'   : 0, 'K_category_Medium': 0, 'K_category_High': 0
    }

    # activate correct categories
    if n_category in ['Low','Medium','High']:
        input_dict[f'N_category_{n_category}'] = 1
    if p_category in ['Low','Medium','High']:
        input_dict[f'P_category_{p_category}'] = 1
    if k_category in ['Low','Medium','High']:
        input_dict[f'K_category_{k_category}'] = 1

    # align columns and scale
    input_df = pd.DataFrame([input_dict]).reindex(columns=X.columns, fill_value=0)
    input_df[num_cols] = sc.transform(input_df[num_cols])

    # predict and convert back to 1-indexed frequency
    pred_class = rf.predict(input_df)[0]
    return int(pred_class) + 1

# predict_irrigation_frequency("rice",20,82,30,"Ladakh")

irrigation_components = {
    "model": rf,
    "scaler": sc,
    "le_crop": le_crop,
    "columns": X.columns,
    "state_nutrient_map": state_nutrient_map
}

# Save the entire dictionary to a single file in the correct backend location
output_path = project_root / "backend" / "app" / "ml_models" / "irrigation_model_components.joblib"
output_path.parent.mkdir(exist_ok=True) # Ensure the directory exists
joblib.dump(irrigation_components, output_path)

print(f"Model, scaler, encoder, columns, and state map saved to {output_path}")